<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta content="width=device-width,initial-scale=1,minimal-ui" name="viewport">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic|Material+Icons">
  <link rel="stylesheet" href="https://unpkg.com/vue-material/dist/vue-material.min.css">
  <link rel="stylesheet" href="https://unpkg.com/vue-material/dist/theme/default.css">
</head>

<body>
  <div id="app">
    <frwa-progress-bar></frwa-progress-bar>
    <frwa-snackbar></frwa-snackbar>
    <router-view></router-view>
  </div>

  <script src="https://unpkg.com/vue"></script>
  <script src="https://unpkg.com/vuex"></script>
  <script src="https://unpkg.com/vue-router"></script>
  <script src="https://unpkg.com/vue-material"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>

  <!-- <frwa-snackbar> -->
  <script type="text/x-template" id="frwa-snackbar-template">
    <md-snackbar md-position="center" :md-active.sync="active" md-persistent>
      <span>{{ message }}</span>
      <md-button class="md-primary" @click="close">Close</md-button>
    </md-snackbar>
  </script>
  <script>
    Vue.component('frwa-snackbar', {
      template: '#frwa-snackbar-template',
      data: () => ({
        active: false,
        message: null,
      }),
      mounted() {
        this.$store.watch((state) => state.lastError, (lastError) => {
          this.message = lastError
          this.active = true
        })
      },
      methods: {
        close() {
          this.active = false
        },
      },
    })
  </script>

  <!-- <frwa-progress-bar> -->
  <script type="text/x-template" id="frwa-progress-bar-template">
    <md-progress-bar md-mode="query" v-if="busy" style="position:fixed;top:0;width:100%;z-index:10"></md-progress-bar>
  </script>
  <script>
    Vue.component('frwa-progress-bar', {
      template: '#frwa-progress-bar-template',
      computed: Vuex.mapGetters(['busy']),
    })
  </script>

  <!-- <frwa-people> -->
  <script type="text/x-template" id="frwa-people-template">
    <md-chips v-model="names" :md-static="!editable"
      @md-click="clickName" @md-delete="deleteName" @md-insert="insertName"
      md-placeholder="Name..." :md-check-duplicated="true"
      class="pulse-on-error">
      <template slot="md-chip" slot-scope="{ chip }">
        <span class="person-name"
          :class="{highlighted: highlightedNames.includes(chip), clickable}">
          {{chip}}
        </span>
      </template>
    </md-chips>
  </script>
  <style>
    .person-name.highlighted {
      font-weight: bold
    }
    .person-name.clickable:hover {
      font-weight: bold
    }
  </style>
  <script>
    Vue.component('frwa-people', {
      template: '#frwa-people-template',
      props: {
        people: {
          type: Array,
          default: () => [],
        },
        highlightedIds: {
          type: Array,
          default: () => [],
        },
        editable: {
          type: Boolean,
          default: false,
        },
        clickable: {
          type: Boolean,
          default: false,
        },
      },
      data() {
        return {
          names: this.getNames(this.people),
        }
      },
      watch: {
        people(newPeople) {
          this.names = this.getNames(newPeople)
        }
      },
      computed: {
        highlightedNames() {
          return this.getNames(
            this.people.filter(
              person => this.highlightedIds.includes(person.id)))
        },
        personByName() {
          return this.people.reduce(
            (map, person) => {
              return { ...map, [person.name]: person }
            }, {})
        },
      },
      methods: {
        getNames(people) {
          return people.map(person => person.name)
        },
        clickName(name) {
          this.$emit('click', this.personByName[name])
        },
        async deleteName(name) {
          this.names = this.getNames(this.people)
          if (!window.confirm(`Reallly delete ${name}?`)) return
          let person = this.personByName[name]
          await this.$store.dispatch('deletePerson', person)
          this.$emit('delete', person)
        },
        async insertName(name) {
          this.names = this.getNames(this.people)
          let person = await this.$store.dispatch('newPerson', { name })
          this.$emit('insert', person)
        },
      }
    })
  </script>

  <!-- <frwa-face-image> -->
  <script type="text/x-template" id="frwa-face-image-template">
    <svg v-if="face && image" :viewBox="viewBox" @click="showLandmarks = !showLandmarks; $emit('click', face)">
      <defs>
        <clipPath id="faceClipPath">
          <circle :cx="cx" :cy="cy" :r="r" />
        </clipPath>
      </defs>
      <image x="0" y="0" :width="image.width" :height="image.height"
        clip-path="url(#faceClipPath)"
        :xlink:href="image.data_uri"></image>
      <polyline v-if="showLandmarks" v-for="(points, label) in face.labeled_landmarks" :key="face.id + label"
        :points="points.map(p=>p[0]+','+p[1]).join(' ')"
        fill="none" stroke="red" />
    </svg>
  </script>
  <script>
    Vue.component('frwa-face-image', {
      template: '#frwa-face-image-template',
      props: ['face', 'image'],
      data() {
        return {
          showLandmarks: false,
        }
      },
      computed: {
        viewBox() {
          return `${this.cx - this.r} ${this.cy - this.r} ${2 * this.r} ${2 * this.r}`
        },
        cx() {
          return (this.face.image_region.left + this.face.image_region.right) / 2
        },
        cy() {
          return (this.face.image_region.top + this.face.image_region.bottom) / 2
        },
        r() {
          return Math.sqrt(
            (this.face.image_region.right - this.face.image_region.left) ** 2 +
            (this.face.image_region.bottom - this.face.image_region.top) ** 2
          ) / 2
        },
      },
    })
  </script>

  <!-- <frwa-face-dialog> -->
  <script type="text/x-template" id="frwa-face-dialog-template">
    <md-dialog v-if="face" :md-active.sync="internalActive">
      <md-card>
        <md-card-header>
          <div class="md-title">Detected Face</div>
        </md-card-header>
        <md-card-content>
          <md-list class="md-dense">
            <md-list-item>
              <table><tr>
                <td>
                  <frwa-face-image :face="face" :image="image" width="100" height="100"/>
                </td><td>
                  <md-progress-spinner :md-value="100 * face.face_score" md-mode="determinate"/>
                  <div class="md-helper-text">Face score</div>
                </td><td>
                  <md-progress-spinner :md-value="100 * face.joy_score" md-mode="determinate"/>
                  <div class="md-helper-text">Joy score</div>
                </td>
              </tr></table>
            </md-list-item>
            <md-divider/>
            <md-list-item>
              <frwa-people :people="Object.values($store.state.personById)"
                :editable="true"
                :clickable="true" @click="onClickPerson"
                @insert="onInsertPerson"
                @delete="onDeletePerson"
                :highlightedIds="face.person ? [face.person]: []">
              </frwa-people>
            </md-list-item>
          </md-list>
        </md-card-content>
        <md-card-actions>
          <md-button class="md-accent" @click="deleteFace">
            <md-icon>delete</md-icon>Bad Detection
          </md-button>
          <md-button @click="internalActive = false">Close</md-button>
        </md-card-actions>
      </md-card>
    </md-dialog>
  </script>
  <script>
    Vue.component('frwa-face-dialog', {
      template: '#frwa-face-dialog-template',
      props: ['face', 'active', 'image'],
      data() {
        return {
          internalActive: this.active,
        }
      },
      watch: {
        active(value) {
          this.internalActive = value
        },
        internalActive(value) {
          this.$emit('update:active', value)
        },
      },
      methods: {
        deleteFace() {
          this.$emit('delete:face', this.face)
        },
        onClickPerson(person) {
          if (this.face.person === person.id) {
            this.$emit('unselect:person', person)
          } else {
            this.$emit('select:person', person)
          }
        },
        onInsertPerson(person) {
          this.$emit('select:person', person)
        },
        onDeletePerson(person) {
          if (this.face.person === person.id) {
            this.$emit('unselect:person', person)
          }
        },
      },
    })
  </script>

  <!-- <frwa-pager> -->
  <script type="text/x-template" id="frwa-pager-template">
    <div v-if="ids" @keyup.left="prev" @keyup.right="next" tabindex="0">
      <span @click="prev"><md-icon>chevron_left</md-icon></span>
      {{index + 1}} of {{ids.length}}
      <span @click="next"><md-icon>chevron_right</md-icon></span>
    </div>
  </script>
  <script>
    Vue.component('frwa-pager', {
      template: '#frwa-pager-template',
      props: {
        id: { type: String },
        ids: { type: Array, required: true },
      },
      computed: {
        index() {
          return this.ids.indexOf(this.id)
        },
      },
      watch: {
        index(newIndex, oldIndex) {
          // adjust the index if it becomes invalid
          if (newIndex >= 0) return
          if (oldIndex < 0) return
          if (this.ids.length === 0) return
          // try to keep the same index
          let index = Math.min(oldIndex, this.ids.length - 1)
          this.$emit('update:id', this.ids[index])
        },
      },
      methods: {
        prev() {
          if (this.index < 0) return
          let newIndex
          if (this.index === 0) {
            newIndex = this.ids.length - 1
          } else {
            newIndex = this.index - 1
          }
          this.$emit('update:id', this.ids[newIndex])
        },
        next() {
          if (this.index < 0) return
          let newIndex
          if (this.index === this.ids.length - 1) {
            newIndex = 0
          } else {
            newIndex = this.index + 1
          }
          this.$emit('update:id', this.ids[newIndex])
        },
      },
    })
  </script>

  <!-- <frwa-image> -->
  <script type="text/x-template" id="frwa-images-template">
    <md-empty-state
      v-if="ids.length === 0"
      md-icon="tag_faces"
      :md-label="noIdsLabel"
      md-description="Let the camera capture a few mugshots, then come back and tag your friends to allow face recognition to work!">
    </md-empty-state>
    <div v-else>
      <div style="position:relative">
        <md-button class="md-raised md-accent" style="position:absolute;bottom:1em" @click="deleteImage">
          <md-icon>delete</md-icon>Bad detection
        </md-button>
        <svg v-if="image"
          :viewBox="'0 0 ' + image.width + ' ' + image.height"
          :style="`max-width:${image.width}px`">
          <image x="0" y="0" :width="image.width" :height="image.height" :xlink:href="image.data_uri"></image>
          <frwa-svg-face v-for="face in faces" :key="face.id" :face="face" @click="onFaceClick" />
        </svg>
      </div>
      <frwa-pager :ids="ids" :id="image ? image.id : null" @update:id="loadImage($event)"/>
      <frwa-people :people="detectedPeople" :clickable="true"/>
      <frwa-face-dialog :image="image" :face="selectedFace" :active.sync="showFaceDialog"
        @select:person="onSelectPerson"
        @unselect:person="onUnselectPerson"
        @delete:face="onDeleteFace"/>
    </div>
  </script>
  <script>
    Vue.component('frwa-images', {
      template: '#frwa-images-template',
      props: ['id', 'kind'],
      data() {
        return {
          ids: [],
          image: null,
          faces: [],
          showFaceDialog: false,
          selectedFace: null,
        }
      },
      watch: {
        id: function (newId, oldId) {
          this.loadImage(this.determineId(this.ids, newId))
        },
        kind: function (newKind, oldKind) {
          this.loadIds(newKind)
        },
        ids: function (newIds, oldIds) {
          this.loadImage(this.determineId(newIds, this.id))
        },
        image: function (newImage, oldImage) {
          if (newImage) {
            this.loadFaces(newImage.detected_faces)
          }
        },
        'image.id': function (newId, oldId) {
          if (newId) this.$emit('update:id', newId)
        },
      },
      computed: {
        noIdsLabel() {
          switch (this.kind) {
            case 'untagged':
              return 'No untagged faces!'
            default:
              return 'No images :('
          }
        },
        detectedPeopleIds() {
          let detectedPeopleIds = new Set()
          this.faces.forEach(face => {
            if (face.person) detectedPeopleIds.add(face.person)
          })
          return Array.from(detectedPeopleIds)
        },
        detectedPeople() {
          return this.detectedPeopleIds.map(
            id => this.$store.state.personById[id]
          ).filter(person => person)
        },
      },
      mounted() {
        this.loadIds(this.kind)
      },
      methods: {
        determineId(ids, requestedId) {
          if (ids && this.ids.includes(requestedId)) {
            return requestedId
          } else if (ids && ids.length > 0) {
            return ids[0]
          } else {
            return null
          }
        },
        async loadIds(kind) {
          function url() {
            switch (kind) {
              case 'all': return '/ids/Image'
              case 'untagged': return 'ids/Image/untagged'
              default: throw new Error('Unsupported kind ' + kind)
            }
          }
          let result = await this.$store.dispatch('doAction', {
            name: 'loadImageIds',
            action: () => axios.get(url())
          })
          this.ids = result.data
        },
        async loadImage(id) {
          if (!id) {
            this.image = null
            return
          }
          if (this.image && this.image.id === id) return
          let response = await this.$store.dispatch('doAction', {
            name: 'loadImage',
            action: () => axios.get('/entity/Image/' + id)
          })
          this.image = response.data
          this.showFaceDialog = false
        },
        async loadFaces(ids) {
          let responses = await this.$store.dispatch('doAction', {
            name: 'loadFaces',
            action: () => Promise.all(
              ids.map(
                id => axios.get('/entity/DetectedFace/' + id)))
          })
          this.faces = responses.map(response => response.data)
        },
        async deleteImage() {
          if (!this.image) return
          await this.$store.dispatch('doAction', {
            name: 'deleteImage',
            action: () => axios.delete('/entity/Image/' + this.image.id),
          })

          this.ids = this.ids.filter(filteredId => filteredId !== this.image.id)
        },
        onFaceClick(face) {
          this.selectedFace = face
          this.showFaceDialog = true
        },
        async onSelectPerson(person) {
          if (!this.selectedFace) return
          await this.$store.dispatch('linkFaceToPerson', {
            face: this.selectedFace,
            person: person,
          })
          this.showFaceDialog = false
        },
        async onUnselectPerson(person) {
          if (!this.selectedFace) return
          await this.$store.dispatch('unlinkFaceFromPerson', {
            face: this.selectedFace,
            person: person,
          })
        },
        async onDeleteFace(face) {
          await this.$store.dispatch('deleteFace', { face })
          this.showFaceDialog = false
          let updatedFaces = this.image.detected_faces.filter(id => id !== face.id)
          this.image = { ...this.image, detected_faces: updatedFaces }
        },
      },
    })
  </script>

  <!-- <frwa-svg-face> -->
  <script type="text/x-template" id="frwa-svg-face-template">
    <g @click="$emit('click', face)">
      <rect :x="face.image_region.left" :y="face.image_region.top" :rx="5" :ry="5"
        :width="face.image_region.right - face.image_region.left"
        :height="face.image_region.bottom - face.image_region.top"
        fill-opacity="0" stroke="white" stroke-width="2" />
      <polyline v-for="(points, label) in face.labeled_landmarks" :key="face.id + label"
        :points="points.map(p=>p[0]+','+p[1]).join(' ')"
        fill="none" stroke="red" />
    </g>
  </script>
  <script>
    Vue.component('frwa-svg-face', {
      template: '#frwa-svg-face-template',
      props: ['face'],
      computed: {
        person() {
          return this.$store.state.personById[this.face.person]
        },
        name() {
          if (this.person) return this.person.name
        },
      },
    })
  </script>

  <script>
    Vue.use(Vuex)
    Vue.use(VueRouter)
    Vue.use(VueMaterial.default)

    // workaround for [1] until [2] gets merged into vue-material
    // 1: https://github.com/vuematerial/vue-material/issues/1977
    // 2: https://github.com/vuematerial/vue-material/pull/1978
    Vue.component('router-link', Vue.options.components.RouterLink);
    Vue.component('router-view', Vue.options.components.RouterView);

    const store = new Vuex.Store({
      strict: true,
      state: {
        countByAction: {},
        lastError: null,
        personById: {},
      },
      getters: {
        busy: state => {
          let totalCount = Object.values(state.countByAction).reduce((a, b) => a + b, 0)
          return totalCount > 0
        },
        people: state => Object.values(state.personById),
        personByName: (state, getters) => {
          const reducer = (acc, person) => {
            return { ...acc, [person.name]: person }
          }
          return getters.people.reduce(reducer, {})
        },
        names: (state, getters) => Object.keys(getters.personByName),
      },
      mutations: {
        START_ACTION(state, { name }) {
          let count = state.countByAction[name] || 0
          state.countByAction = { ...state.countByAction, [name]: count + 1 }
        },
        STOP_ACTION(state, { name }) {
          let count = state.countByAction[name] || 0
          if (count < 1) {
            throw Error(`Action ${name} stopped more times than started`)
          }
          state.countByAction = { ...state.countByAction, [name]: count - 1 }
        },
        SET_LAST_ERROR(state, { error }) {
          state.lastError = error
        },
        SET_PEOPLE(state, { people }) {
          const reducer = (acc, person) => {
            return { ...acc, [person.id]: person }
          }
          state.personById = people.reduce(reducer, {})
        },
        ADD_PERSON(state, { person }) {
          state.personById = { ...state.personById, [person.id]: person }
        },
        DELETE_FACE(state, { face }) {
          if (!face.person) return
          let person = state.personById[face.person]
          if (!person) throw new Error('Face references unknown person')
          let updatedPerson = { ...person, detected_faces: person.detected_faces.filter(faceId => faceId !== face.id) }
          state.personById = { ...state.personById, [face.person]: updatedPerson }
        },
        DELETE_PERSON(state, { id }) {
          let personById = { ...state.personById }
          delete personById[id]
          state.personById = personById
        },
        LINK_FACE_TO_PERSON(state, { face, person }) {
          face.person = person.id
          if (person.detected_faces.includes(face)) return
          let updatedPerson = { ...person, detected_faces: [...person.detected_faces, face] }
          state.personById = { ...state.personById, [person.id]: updatedPerson }
        },
        UNLINK_FACE_FROM_PERSON(state, { face, person }) {
          if (face.person && face.person !== person.id) {
            throw new Error('Face is currently linked to a different person')
          }
          face.person = null
          if (!state.personById[person.id]) return
          if (!person.detected_faces.includes(face)) return
          let updatedPerson = { ...person, detected_faces: person.detected_faces.filter(faceId => faceId !== face.id) }
          state.personById = { ...state.personById, [person.id]: updatedPerson }
        },
      },
      actions: {
        async doAction({ commit }, { name, action }) {
          commit('START_ACTION', { name })
          try {
            return await action()
          } catch (e) {
            commit('SET_LAST_ERROR', { error: `Action '${name}' failed. ${e.toString()}` })
            throw e
          } finally {
            commit('STOP_ACTION', { name })
          }
        },
        async loadPeople({ dispatch, commit }) {
          let result = await dispatch('doAction', {
            name: 'loadPeople',
            action: () => axios.get('/entity/Person')
          })
          commit('SET_PEOPLE', { people: result.data })
        },
        async newPerson({ dispatch, commit }, { name }) {
          let person = await dispatch('doAction', {
            name: 'newPerson',
            async action() {
              let result = await axios.post('/entity/Person', { name })
              return result.data
            }
          })
          commit('ADD_PERSON', { person })
          return person
        },
        async deleteFace({ dispatch, commit, getters }, { face }) {
          let result = await dispatch('doAction', {
            name: 'deleteFace',
            action: () => axios.delete('/entity/DetectedFace/' + face.id)
          })
          commit('DELETE_FACE', { face })
        },
        async deletePerson({ dispatch, commit, getters }, { id }) {
          let result = await dispatch('doAction', {
            name: 'deletePerson',
            action: () => axios.delete('/entity/Person/' + id)
          })
          commit('DELETE_PERSON', { id })
        },
        async linkFaceToPerson({ dispatch, commit }, { face, person }) {
          await dispatch('doAction', {
            name: 'linkFaceToPerson',
            action: () => axios.post('/link_face_to_person', {
              face_id: face.id,
              person_id: person.id,
            })
          })
          commit('LINK_FACE_TO_PERSON', { face, person })
        },
        async unlinkFaceFromPerson({ dispatch, commit }, { face, person }) {
          await dispatch('doAction', {
            name: 'unlinkFaceFromPerson',
            action: () => axios.post('/unlink_face_from_person', {
              face_id: face.id,
              person_id: person.id,
            })
          })
          commit('UNLINK_FACE_FROM_PERSON', { face, person })
        },
      },
    })

    const router = new VueRouter({
      routes: [{
        path: '/',
        redirect: '/images/all',
      }, {
        path: '/images/:kind/:id?',
        component: {
          computed: {
            id: {
              get() {
                return this.$route.params.id
              },
              set(id) {
                this.$router.push({ params: { id } })
              }
            },
            kind: {
              get() {
                return this.$route.params.kind
              },
              set(kind) {
                this.$router.push({ params: { kind } })
              }
            },
          },
          template: `
            <div>
              <md-tabs :md-active-tab="kind" @md-changed="kind=$event">
                <md-tab id="all" md-label="All"/>
                <md-tab id="untagged" md-label="Untagged"/>
              </md-tabs>
              <frwa-images v-bind="{id, kind}" @update:id="id=$event"/>
            </div>
          `,
        },
      }, {
        path: '*',
        component: {
          template: `
              <md-empty-state md-icon="error" md-label="Page not found!">
                  <md-button class="md-primary md-raised" @click="$router.push({path: '/'})">Get me outta here!</md-button>
              </md-empty-state>
            `,
        },
      }],
    })

    new Vue({
      el: '#app',
      store,
      router,
      mounted() {
        this.$store.dispatch('loadPeople')
      }
    })
  </script>
</body>

</html>